<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Micronaut Advantages on Micronaut MuShop</title>
    <link>/micronaut/</link>
    <description>Recent content in Micronaut Advantages on Micronaut MuShop</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="/micronaut/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cloud Native Configuration</title>
      <link>/micronaut/cloudnative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/cloudnative/</guid>
      <description>A significant advantage of Micronaut is the ability to use Cloud Native configuration.
Each Micronaut application is able to define an application-oraclecloud.yml file that is automatically activated when deployed into the Oracle Cloud environment.
This allows the Micronaut applications to adapt to run on any Cloud and simplifies deployment.
Decoupling distributed configuration and service discovery responsibilities leads to significant simplifications in the code.
Each Micronaut application has no direct references to Oracle Cloud and can easily be migrated from one Cloud to another simplify by providing the appropriate configuration for the Cloud platform being used.</description>
    </item>
    
    <item>
      <title>Service Discovery</title>
      <link>/micronaut/service-discovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/service-discovery/</guid>
      <description>In a Microservice architecture services need to discover each other in a decoupled manner that is independent of the service discovery mechanism.
Micronaut features a Service Discovery abstraction that allows service discovery to be backed onto different implementations including Kubernetes, HashiCorp Consul, Eureka and more.
The original MuShop application featured extensive handcrafted service discovery code in both the Spring application:
 OrdersConfigurationProperties &amp;amp; RestProxyTemplate - hand crafted Spring service discovery configuration handling OrdersConfigurationProperties &amp;amp; RestProxyTemplate - hand crafted Spring service discovery configuration handling  And Node/Express JavaScript API:</description>
    </item>
    
    <item>
      <title>Distributed Tracing</title>
      <link>/micronaut/tracing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/tracing/</guid>
      <description>The original MuShop application featured hand crafted logic to wrap each endpoint in distributed tracing logic that can be exported to Zipkin, for example in the Go lang code which manually wraps logic in calls to opentracing.TraceServer(..):
func MakeEndpoints(s Service, tracer stdopentracing.Tracer) Endpoints { return Endpoints{ ListEndpoint: opentracing.TraceServer(tracer, &amp;#34;GET /catalogue&amp;#34;)(MakeListEndpoint(s)), CountEndpoint: opentracing.TraceServer(tracer, &amp;#34;GET /catalogue/size&amp;#34;)(MakeCountEndpoint(s)), GetEndpoint: opentracing.TraceServer(tracer, &amp;#34;GET /catalogue/{id}&amp;#34;)(MakeGetEndpoint(s)), CategoriesEndpoint: opentracing.TraceServer(tracer, &amp;#34;GET /categories&amp;#34;)(MakeCategoriesEndpoint(s)), HealthEndpoint: opentracing.TraceServer(tracer, &amp;#34;GET /health&amp;#34;)(MakeHealthEndpoint(s)), } } Micronaut has built-in support for distributed tracing that only requires the addition of the micronaut-tracing module and then configuring the target Zipkin or Jaeger service to send traces to, for example in the micronaut-oraclecloud.</description>
    </item>
    
    <item>
      <title>Health Checks &amp; Observability</title>
      <link>/micronaut/management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/management/</guid>
      <description>The original MuShop application features extensive code to define application health observability endpoints.
For example the original Go lang code features manual definition of the /health endpoint in endpoints.go:
func MakeHealthEndpoint(s Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (response interface{}, err error) { health := s.Health() return healthResponse{Health: health}, nil } } As well as a manually implemented health check routine in services.go:
func (s *catalogueService) Health() []Health { var health []Health dbstatus := &amp;#34;OK&amp;#34; err := s.</description>
    </item>
    
    <item>
      <title>Application Metrics and Monitoring</title>
      <link>/micronaut/metrics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/metrics/</guid>
      <description>The original MuShop applications implemented exposing metrics inconsistently with some applications exporting metrics and others not. The applications that did export metrics provided support only for Prometheus, for example in the Go code:
r.Handle(&amp;#34;/metrics&amp;#34;, promhttp.Handler()) Micronaut builds on Micrometer and supports exporting Metrics to over a dozen metrics backends including Prometheus and Oracle Cloud.
Every single application in the Micronaut MuShop demonstration exports metrics consistently and uniformally through the addition of this simple configuration:</description>
    </item>
    
    <item>
      <title>Connecting Autonomous Database</title>
      <link>/micronaut/atp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/atp/</guid>
      <description>The original MuShop reference applications contained significant logic in order to download and configure the Oracle Wallet definition to connect to autonomous database.
The details of this requirement are described in Application Configuration section of the original MuShop.
Developers have to enhance their CI pipeline to ensure the client credentials contained with the Oracle Wallet are packaged within the file system of the Docker container before uploading. The downside of this approach is that every time the Oracle Wallet is rotated a new container image needs to be built.</description>
    </item>
    
    <item>
      <title>Database Access</title>
      <link>/micronaut/data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/data/</guid>
      <description>The original MuShop application includes a lot of handwritten SQL logic that is greatly simplified by the use of Micronaut Data.
In the Go version of the following code, SQL is appended together manually and executed in order to perform a count:
func (s *catalogueService) Count(categories []string) (int, error) { query := &amp;#34;SELECT COUNT(DISTINCT products.sku) FROM products JOIN product_category ON products.sku=product_category.sku JOIN categories ON product_category.category_id=categories.category_id&amp;#34; var args []interface{} for i, t := range categories { if i == 0 { query += &amp;#34; WHERE categories.</description>
    </item>
    
    <item>
      <title>OpenAPI / Swagger</title>
      <link>/micronaut/openapi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/openapi/</guid>
      <description>In the original MuShop sample application most of the applications defined manually crafted OpenAPI definitions that in fact were in some cases out-of-date with the actual state of the code.
Keeping the OpenAPI documentation for a service aligned with the actual code can be a real challenge.
With the Micronaut MuShop every single applications defines an accessible OpenAPI definition available via Swagger UI.
For example you can cd into the api service and run the application with:</description>
    </item>
    
    <item>
      <title>Gateway Service</title>
      <link>/micronaut/gateway/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/gateway/</guid>
      <description>The original MuShop api service is written in Node/Express and services as a Gateway service to access other services.
Apart from the already mentioned manual service discovery implementation the Node Gateway service implements all routing logic manually:
app.get(&amp;#34;/catalogue*&amp;#34;, function (req, res, next) { req.svcClient() .get(endpoints.catalogueUrl + req.url.toString()) .then(({ data }) =&amp;gt; res.json(data)) .catch(next); }); In Micronaut this is simplified through the use of service discovery combined with the declarative client to allow requests to be easily proxied:</description>
    </item>
    
    <item>
      <title>Security</title>
      <link>/micronaut/security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/security/</guid>
      <description>The original MuShop api service includes a lot of error prone logic to assert security rules at the API gateway layer, for example:
router.get(&amp;#39;/orders&amp;#39;, (req, res) =&amp;gt; { if (!helpers.isLoggedIn(req)) { return next(helpers.createError(&amp;#34;User not logged in.&amp;#34;, 401)); } const custId = helpers.getCustomerId(req); res.json(this.orders.find(row =&amp;gt; custId === row.customer.id)); }) It is very easy to forget an isLoggedIn call causing a security vulnerability in your application.
The Micronaut version of the Gateway includes the Micronaut Security module which is locked down by default with every request to the API service by default returning a 401 unless the user is logged in.</description>
    </item>
    
    <item>
      <title>Messaging</title>
      <link>/micronaut/messaging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/messaging/</guid>
      <description>The original Spring-based application includes extensive logic to send NATs messages.
This is greatly simplified in Micronaut with the Micronaut NATS module:
@NatsClient public interface OrdersPublisher { @Subject(&amp;#34;mushop-orders&amp;#34;) void dispatchToFulfillment(OrderUpdate orderUpdate); } In the above example Micronaut automatically implements the logic to send a message and handle any errors, avoiding 115 lines of additional code.
To Go application that sends events via OCI streaming again features over a 100 lines of code to send messages with the OCI SDK.</description>
    </item>
    
    <item>
      <title>HTTP Client</title>
      <link>/micronaut/httpclient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/httpclient/</guid>
      <description>Micronaut features an HTTP client that is included by default and automatically instrumented for distributed tracing, service discovery and metrics. The Spring application in the original MuShop features many manually written HTTP calls that amount to another 100 lines of additional code.
This HTTP client logic was completely removed in the Micronaut application as the existing HTTP client was simply injected via service discovery:
public OrdersService(CustomerOrderRepository customerOrderRepository, MeterRegistry meterRegistry, OrdersPublisher ordersPublisher, PaymentClient paymentClient, OrdersConfiguration ordersConfiguration, @Client(&amp;#34;users&amp;#34;) RxHttpClient userClient, // HTTP clients injected here  @Client(&amp;#34;carts&amp;#34;) RxHttpClient cartsClient) { .</description>
    </item>
    
    <item>
      <title>Deployment</title>
      <link>/micronaut/deployment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/deployment/</guid>
      <description>Each example application in the original MuShop features a hand-crafted Dockerfile that the developer has to write and maintain including ensuring all images used in the Dockerfile are kept up-to-date to avoid security vulnerabilities.
None of the Micronaut applications feature a Dockerfile which is provided automatically and maintained by the framework across releases, making deploying an image a simple matter of executing:
./gradlew dockerPush for Gradle, or alternatively for Maven:</description>
    </item>
    
    <item>
      <title>GraalVM Native Image</title>
      <link>/micronaut/native/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/micronaut/native/</guid>
      <description>Every single application in the Micronaut MuShop can be built into a GraalVM native image and deployed natively as well as in JIT mode allowing the developer to flexibly choose their preferred deployment model and benefit from massive reductions in memory usage and startup time when choosing native.
To build any of the services into a native image simply navigate to the to the project directory and if using Gradle run:</description>
    </item>
    
  </channel>
</rss>
